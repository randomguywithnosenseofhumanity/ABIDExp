debugX = true

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
	Name = "BFDIA By Sakura INC Exploits - Slimerky Hub",
	Icon = 105469178605926, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
	LoadingTitle = "BFDIA exploits",
	LoadingSubtitle = "by Slimerky Hub",
	Theme = "AmberGlow", -- Check https://docs.sirius.menu/rayfield/configuration/themes

	DisableRayfieldPrompts = false,
	DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

	ConfigurationSaving = {
		Enabled = true,
		FolderName = nil, -- Create a custom folder for your hub/game
		FileName = "Slimerky Hub"
	},

	Discord = {
		Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
		Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
		RememberJoins = true -- Set this to false to make them join the discord every time they load it up
	},

	KeySystem = true, -- Set this to true to use our key system
	KeySettings = {
		Title = "Slimerky Hub - Key System",
		Subtitle = "no need for discord",
		Note = "Say something positive about Slimerky!", -- Use this to tell the user how to get a key
		FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
		SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
		GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
		Key = {"ILOVESLIMERKY"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
	}
})

local Tab = Window:CreateTab("Checkers", 105469178605926) -- Title, Image

local Section = Tab:CreateSection("Note: If it shows blank, it means there is none, if it says Environment, it means there is a token on the map, if it shows an user, it means that the user has the token.")

local Button = Tab:CreateButton({
	Name = "Check Tokens",
	Callback = function()
		-- names of the StringValues in workspace.GameData (edit if your names differ)
		local tokenNames = {"CurseToken1", "CurseToken2", "WinToken1", "WinToken2"}

		-- build messages table from workspace.GameData
		local messages = {}
		local gameData = workspace:FindFirstChild("GameData")
		for _, tname in ipairs(tokenNames) do
			local text = tname .. " = " .. "nil" -- fallback if not found
			if gameData then
				local sv = gameData:FindFirstChild(tname)
				if sv and sv:IsA("StringValue") then
					text = tname .. " = " .. tostring(sv.Value)
				else
					text = tname .. " = " .. "NOT FOUND"
				end
			else
				text = tname .. " = " .. "NO GameData"
			end
			table.insert(messages, text)
		end

		-- client-only GUI setup (prevents duplicates)
		local player = game.Players.LocalPlayer
		if not player then return end
		local playerGui = player:WaitForChild("PlayerGui")

		if playerGui:FindFirstChild("ClientMessage") then
			playerGui.ClientMessage:Destroy()
		end

		local screenGui = Instance.new("ScreenGui")
		screenGui.Name = "ClientMessage"
		screenGui.ResetOnSpawn = false
		screenGui.Parent = playerGui

		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 0.1, 0)         -- full width, 10% height
		label.Position = UDim2.new(0, 0, 0, 0)       -- top of screen
		label.BackgroundTransparency = 0.3
		label.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.Font = Enum.Font.GothamBold
		label.TextScaled = true
		label.Text = "" -- start empty
		label.Parent = screenGui

		-- show each message for 3 seconds (total 12s), then cleanup
		task.spawn(function()
			for _, msg in ipairs(messages) do
				label.Text = msg
				task.wait(3) -- show for 3 seconds
			end
			if screenGui then
				screenGui:Destroy()
			end
		end)
	end,
})

local Tab1 = Window:CreateTab("Change", 105469178605926) -- Title, Image

local Section1 = Tab1:CreateSection("Change Speed")

local Slider = Tab1:CreateSlider({
	Name = "Walkspeed",
	Range = {0, 150},
	Increment = 1,
	Suffix = "Speed",
	CurrentValue = 18,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Value)
	end,
})
local Button1 = Tab1:CreateButton({
	Name = "Set Normal WalkSpeed",
	Callback = function()
		game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 18
	end,
})

local Section2 = Tab1:CreateSection("Change JumpPower")

local Slider1 = Tab1:CreateSlider({
	Name = "JumpPower",
	Range = {0, 300},
	Increment = 1,
	Suffix = "JP",
	CurrentValue = 50,
	Flag = "Slider2", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		game.Players.LocalPlayer.Character.Humanoid.JumpPower = (Value)
	end,
})

local Button2 = Tab1:CreateButton({
	Name = "Set Normal JumpPower",
	Callback = function()
		game.Players.LocalPlayer.Character.Humanoid.JumpPower = 50
	end,
})

local Section3 = Tab1:CreateSection("Flying")

local Button3 = Tab1:CreateButton({
	Name = "Fly",
	Callback = function()
--// FlyScript (LocalScript)
--// Toggle with F, or stop via RemoteEvent from another script.

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local root = character:WaitForChild("HumanoidRootPart")
local uis = game:GetService("UserInputService")
local runService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Create or get the stop event
local stopEvent = ReplicatedStorage:FindFirstChild("StopFlyingEvent") or Instance.new("BindableEvent")
stopEvent.Name = "StopFlyingEvent"
stopEvent.Parent = ReplicatedStorage

-- SETTINGS
local TOGGLE_KEY = Enum.KeyCode.F
local ASCEND_KEY = Enum.KeyCode.Space
local DESCEND_KEY = Enum.KeyCode.LeftControl
local SPEED = 70
local ACCEL = 5

-- STATE
local flying = false
local moveDirection = Vector3.zero
local currentVelocity = Vector3.zero
local keysDown = {}

-- Function to disable flying safely
local function disableFlying()
	flying = false
	humanoid.PlatformStand = false
	currentVelocity = Vector3.zero
end

--// Input
uis.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode == TOGGLE_KEY then
		flying = not flying
		if flying then
			humanoid.PlatformStand = true
		else
			disableFlying()
		end
	end

	if input.UserInputType == Enum.UserInputType.Keyboard then
		keysDown[input.KeyCode] = true
	end
end)

uis.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		keysDown[input.KeyCode] = nil
	end
end)

--// Camera-relative movement
local function getDirection()
	local cam = workspace.CurrentCamera
	local forward = cam.CFrame.LookVector
	local right = cam.CFrame.RightVector
	local move = Vector3.zero

	if keysDown[Enum.KeyCode.W] then move += Vector3.new(forward.X, 0, forward.Z) end
	if keysDown[Enum.KeyCode.S] then move -= Vector3.new(forward.X, 0, forward.Z) end
	if keysDown[Enum.KeyCode.A] then move -= Vector3.new(right.X, 0, right.Z) end
	if keysDown[Enum.KeyCode.D] then move += Vector3.new(right.X, 0, right.Z) end

	if move.Magnitude > 0 then move = move.Unit end

	if keysDown[ASCEND_KEY] then
		move += Vector3.new(0, 1, 0)
	elseif keysDown[DESCEND_KEY] then
		move += Vector3.new(0, -1, 0)
	end

	return move
end

--// Flight loop
runService.RenderStepped:Connect(function(dt)
	if not flying then return end
	moveDirection = getDirection()
	local targetVelocity = moveDirection * SPEED
	currentVelocity = currentVelocity:Lerp(targetVelocity, dt * ACCEL)
	root.Velocity = currentVelocity
end)

--// External deactivation
stopEvent.Event:Connect(function()
	if flying then
		disableFlying()
	end
end)
	end,
})


Rayfield:LoadConfiguration()
